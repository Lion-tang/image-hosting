## FISCOBCOS PBFT算法初识

### raft介绍

链中有三种节点角色：follow(有机会变成candidate)、candidate(有机会被投票选举为leader)、leader

candidate按照超过一半票数最多的选举为leader进行记账，该共识算法性能较好，但是安全性较差，因为是选出leader记账，没有人验证

### PBFT介绍

以4个节点为例(node0、node1、node2、node3)，假设node0为Leader

1. pre-prepare阶段

   node0会打包区块把区块封装在prepare数据包内；node0向其他节点广播prepare包；其他节点收到prepare包，执行区块，广播签名包

2. prepare阶段

   节点收集签名包；收集满(2*f+1)个签名包后，向其他节点广播commit请求

3. commmit阶段

   节点收集commit请求；收集满(2*f+1)个commit请求后，将区块写入数据库(上链)

PBFT安全性好，但是扩展性较差

### rPBFT介绍

为了克服PBFT的网络扩展问题，webank研究了raft和pbft结合的自研rPBFT算法

rPBFT将节点分为**出块节点**和**验证节点**，核心思想是基于`VRF`算法，周期性地替换共识节点，保障系统安全

系统包含三个参数

1. epoch_selaer_num：共识节点数
2. epoch_sealer_rotating_num：替换共识节点的数目
3. epoch_block_num：出块节点更替周期，每出epoch_block_num个区块后，替换epoch_sealer_rotating_num个共识节点

算法要求至少2/3的共识节点能正常运行才能保证系统正常运行，即只能容忍1/3的错误节点

对于安全要求高的系统，epoch_sealer_num调小些，epoch_block_num调大些；对于性能有要求的系统，则反之

### 其他优化策略

#### 并行区块编解码

优化前：传输和存储区块使用RLP(Recursive  Length Prefix，递归长度前缀编码)编码方案，由于编码是递归的，在**编码**前，无法获知编码后的长度，形成了一种串行的链式依赖关系。解码时，由于RLP编码中每个对象的长度不确定，且RLP编码只记录了对象的个数，没记录对象的字节长度，若要获取其中的一个编码对象，必须递归解码其前序的所有对象，在解码前序的对象后，才能访问到需要访问的编码对象的字节位置

优化后：在RLP编码基础上进行了扩展，在对象计数和对象数组之间加入一个记录对象偏移量的数组，用于随机访问，随机访问就可以将偏移量数组划分为多个独立的片，每个片由一个线程负责，因此可以并行解码对象数组不同部分

#### 工作流优化

优化前：同步模块(使交易能够到达每个节点)、交易池、共识模块都会对区块中交易验签

优化后：从交易池中取交易，减少重复验签的次数，核心思想就是同步模块把同步消息放到交易池，以后无论是同步模块还是共识模块，验签前都去交易池查看是否有交易存在，存在就省去验签步骤

 #### 基于交易哈希的Light Prepare包

优化前：`leader`广播的Prepare包导致交易重复传输

优化后：LightPrepare包内区块只包含交易哈希，其他节点收到`LightPrepare`包后从交易池取命中交易，如果缺失交易就像Leader请求

#### 负载均衡

优化前：由rPBFT分成的两类共识区块和验证区块，如果共识区块全量向验证区块广播，容易造成广播节点负载高，出带宽为O(n)

优化后：树状广播拓扑

该拓扑结构有以下**优势**：

- 无冗余消息包
- 分而治之，每个节点出带宽为O(1)，可扩展性强

有以下劣势：

- 中间节点是单点，需要额外的**容错策略**（基于状态包的消息转发 ）

#### 小数据包容错机制

发起广播的节点带上断连节点的信息，收到消息包的邻居节点去除与自己相邻的节点生成新的断连节点信息，根据断连信息转发消息，直到断连节点信息中包含的节点列表为空，停止转发
